name: CI Workflow

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test-and-cleanup:
    runs-on: ubuntu-latest
    steps:
      # Check out the repository code
      - name: Checkout Code
        uses: actions/checkout@v2

      # Set up Terraform using HashiCorp's official action
      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.3.6  # Specify your desired Terraform version

      # Initialize and validate Terraform code in the terraform/ directory
      - name: Terraform Init and Validate
        working-directory: terraform
        run: |
          terraform init
          terraform validate

      # Create a local Kubernetes cluster using Kind (Kubernetes IN Docker)
      - name: Create Kind Cluster
        uses: crazymax/ghaction-setup-kind@v1
        with:
          version: v0.17.0  # Specify a Kind version

      # Set up kubectl to interact with the Kind cluster
      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.25.0'  # Use a version compatible with Kind

      # Apply Terraform configuration to provision the namespace and infrastructure
      - name: Terraform Apply
        working-directory: terraform
        run: terraform apply -auto-approve
        # This step creates the Kubernetes namespace (and any other infrastructure)

      # Deploy the Kubernetes manifests (secrets, app components, monitoring, network policy)
      - name: Deploy Kubernetes Manifests
        run: |
          # Create secrets first
          kubectl apply -f secrets/
          # Then deploy all components (nginx, postgres, Prometheus, Grafana, etc.)
          kubectl apply -f k8s/
        # Ensure that your manifests refer to the namespace created by Terraform (verkstedt-demo)

      # Wait for the deployments to become available
      - name: Wait for Deployments to be Ready
        run: |
          kubectl wait --for=condition=available --timeout=120s deployment/nginx -n verkstedt-demo
          kubectl wait --for=condition=available --timeout=120s deployment/postgres -n verkstedt-demo
          kubectl wait --for=condition=available --timeout=120s deployment/prometheus -n verkstedt-demo
          kubectl wait --for=condition=available --timeout=120s deployment/grafana -n verkstedt-demo
        # This ensures that pods are running before tests begin

      # Run basic tests (for example, verifying the nginx service is accessible)
      - name: Run Tests
        run: |
          # Running a temporary pod to test connectivity to the nginx service
          kubectl run curl-test --image=curlimages/curl --restart=Never --rm -i -- \
            curl -s http://nginx-service.verkstedt-demo.svc.cluster.local
        # Additional tests (e.g., checking health endpoints) can be added as needed

      # Clean up the deployed Kubernetes resources by deleting the namespace
      - name: Cleanup Kubernetes Resources
        run: |
          kubectl delete namespace verkstedt-demo --ignore-not-found=true
        # Deleting the namespace cleans up all resources deployed in it

      # Destroy the Terraform-managed infrastructure to ensure full cleanup
      - name: Terraform Destroy
        working-directory: terraform
        run: terraform destroy -auto-approve
        # This will tear down the namespace and any resources that were provisioned via Terraform